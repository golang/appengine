// Copyright 2019 Google Inc. All rights reserved.
// Use of this source code is governed by the Apache 2.0
// license that can be found in the LICENSE file.

package datastore

import (
	"sync"

	"golang.org/x/net/context"

	"google.golang.org/appengine/datastore/internal/cloudkey"
	"google.golang.org/appengine/internal"
)

var keyConversion struct {
	mu      sync.RWMutex
	project string
}

// EnableKeyConversion enables encoded key compatibility with the Cloud Datastore client library (cloud.google.com/go/datastore).
// Encoded keys generated by the Cloud Datastore client library will be decoded into App Engine datastore keys.
//
// The context provided must be an App Engine context if running in first generation App Engine.
// This can be called in the /_ah/start handler. It is safe to call multiple times, and is cheap to call, so can also be inserted as middleware.
//
// Enabling key compatibility not affect the encoding format used by Key.Encode, it only expands the type of keys that are able to be decoded with DecodeKey.
func EnableKeyConversion(ctx context.Context) {
	if getKeyConversionAppID() == "" {
		return
	}

	keyConversion.mu.Lock()
	if keyConversion.project == "" {
		keyConversion.project = internal.FullyQualifiedAppID(ctx)
	}
	keyConversion.mu.Unlock()
}

func getKeyConversionAppID() string {
	keyConversion.mu.RLock()
	project := keyConversion.project
	keyConversion.mu.RUnlock()
	return project
}

// decodeCloudKey attempts to decode the given encoded key generated by the Cloud Datastore client library, returning nil if the key couldn't be decoded.
func decodeCloudKey(encoded string) *Key {
	cloudKey, err := cloudkey.DecodeKey(encoded)
	if err != nil {
		return nil
	}
	appID := getKeyConversionAppID()
	converted, err := convertCloudKey(cloudKey, appID)
	if err != nil {
		return nil
	}
	return converted
}

// convertCloudKey converts a Cloud Datastore key and converts it to an App Engine Datastore key.
// Cloud Datastore keys don't include the project/app ID, so we must add it back in.
func convertCloudKey(key *cloudkey.Key, appID string) (*Key, error) {
	var pKey *Key
	var err error
	if key.Parent != nil {
		pKey, err = convertCloudKey(key.Parent, appID)
		if err != nil {
			return nil, err
		}
	}
	return &Key{
		intID:     key.ID,
		kind:      key.Kind,
		namespace: key.Namespace,
		parent:    pKey,
		stringID:  key.Name,
		appID:     appID,
	}, nil
}
